{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Total Electron Content (TEC) reconstruction with GNSS data \u2013 a Python \ud83d\udc0d package with a Rust \ud83e\udd80 core.</p>"},{"location":"#what-is-pytecgg","title":"What is PyTECGg?","text":"<p><code>PyTECGg</code> is a fast, lightweight Python package that helps reconstruct and calibrate the Total Electron Content (TEC) from GNSS data.</p> <p>Why calibration matters? Because without it, you don\u2019t actually know the true value of TEC \u2014 only how it changes. Uncalibrated TEC is affected by unknown biases from satellites and receivers, as well as other sources of error.</p>"},{"location":"#main-features","title":"Main features","text":"<p>This package is designed for researchers and engineers who need speed and reliability.</p> <ul> <li>Blazing fast: powered by a Rust core and Polars, it is much faster than existing pure-Python implementations when parsing large datasets.</li> <li>Open source: read, access, and contribute to all the code.</li> <li>Modern GNSS support: compatible with GPS, Galileo, BeiDou, GLONASS.</li> <li>RINEX ready: supports versions 2, 3, and 4.</li> <li>Seamless decompression: built-in support for Hatanaka-compressed files \u2014 no need to decompress your data manually.</li> </ul>"},{"location":"#get-started","title":"Get started","text":"<p>\ud83d\udce5 Install <code>PyTECGg</code></p> <p>\ud83d\ude80 Quickstart with an hands-on tutorial</p> <p>\ud83e\udd16 Ask the official <code>PyTECGg</code> AI assistant for help</p> <p>\ud83c\udf31 Contribute to the project</p>"},{"location":"contributing/","title":"Contributing to PyTECGg","text":"<p>First off, thanks for taking the time to contribute! \ud83c\udf89 Open source projects like this one thrive on community input.</p>"},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>Whether you want to fix a bug, propose a new feature, improve the documentation, or just ask a question \u2014 you're welcome here!</p> <p>Here are common ways to get involved:</p> <ul> <li>Report bugs</li> <li>Suggest enhancements</li> <li>Submit pull requests</li> <li>Improve documentation</li> <li>Review pull requests</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting started","text":"<ol> <li>Clone the repository and make sure you have the latest version     <pre><code>git checkout develop\ngit pull origin develop\n</code></pre></li> <li>Create your feature branch from <code>develop</code> <pre><code>git checkout -b feature_amazing_feature develop\n</code></pre></li> <li>Make your changes and format your code with <code>black .</code> (please refer to the Code style section)</li> <li>Run tests with <code>pytest</code> to ensure everything works</li> <li>Commit and push to your branch</li> <li>Open a Pull Request (PR) to the <code>develop</code> branch</li> </ol> <p>Please ensure that each commit is atomic (one feature/fix per commit) and includes a clear message. For bigger changes, consider writing a descriptive body.</p>"},{"location":"contributing/#code-style","title":"Code style","text":"<p>This project uses Black as the code formatter: please run <code>black .</code> before pushing your code.</p> <p>Some general conventions:</p> <ul> <li> <p>Write readable, modular code.</p> </li> <li> <p>Add comments (if something isn\u2019t immediately obvious) explaining the why, not the how.</p> </li> <li> <p>Use meaningful variable names.</p> </li> <li> <p>Prefer clarity over cleverness.</p> </li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>If your changes affect functionality, please include appropriate tests or describe how the changes were manually tested. This project uses pytest.</p> <p>Before submitting a PR, please ensure all tests pass by running <code>pytest</code></p>"},{"location":"contributing/#release-process","title":"Release Process","text":"<p>For contributors submitting PRs, please ensure:</p> <ul> <li> <p>You've updated the <code>README.md</code> file \u2014 if your changes affect usage or documentation</p> </li> <li> <p>All tests pass</p> </li> </ul> <p>Once your PR is merged to <code>develop</code>, maintainers will:</p> <ul> <li> <p>Handle version tagging and management</p> </li> <li> <p>Automatically build and publish releases to PyPI</p> </li> <li> <p>Ensure cross-platform compatibility (Windows, Linux, macOS)</p> </li> </ul>"},{"location":"contributing/#bug-reports","title":"Bug reports","text":"<p>If you find a bug, open an issue with the <code>bug</code> tag and:</p> <ul> <li> <p>A clear title</p> </li> <li> <p>A short description of the bug</p> </li> <li> <p>Steps to reproduce (if possible)</p> </li> <li> <p>Expected vs. actual behavior</p> </li> <li> <p>Environment (Python version, OS, etc.)</p> </li> </ul>"},{"location":"contributing/#feature-suggestions","title":"Feature suggestions","text":"<p>Want to propose something new? Great! Open an issue with the enhancement <code>tag</code> and describe:</p> <ul> <li> <p>What the feature does</p> </li> <li> <p>Why it would be useful</p> </li> <li> <p>Any technical considerations or ideas for implementation</p> </li> </ul>"},{"location":"contributing/#community","title":"Community","text":"<p>You can reach out by opening an issue for general discussion or suggestions.</p> <p>Let\u2019s keep things respectful, constructive, and collaborative.</p> <p>Thanks again! \ud83d\udc99</p>"},{"location":"installation/","title":"Installation","text":"<p><code>PyTECGg</code> features a performance-critical core written in Rust and a high-level API in Python. Pre-compiled binaries (wheels) for most common platforms are provided.</p>"},{"location":"installation/#from-pypi-recommended","title":"\ud83d\udce6 From PyPI (recommended)","text":"<p>For most users, the simplest way is to install the pre-built package from PyPI:</p> <pre><code>pip install pytecgg\n</code></pre> <p>This will also install all required Python dependencies automatically.</p>"},{"location":"installation/#from-source-distribution","title":"\ud83d\udee0\ufe0f From source distribution","text":"<p>If you want to compile the package from source (e.g., to benefit from specific CPU optimizations or for inspection), you can force <code>pip</code> to use the source distribution:</p> <pre><code>pip install pytecgg --no-binary :all:\n</code></pre> <p>Note</p> <p>Building from source requires a working Rust toolchain (<code>rustc</code>, <code>cargo</code>).  You can install it via rustup.rs.</p>"},{"location":"installation/#for-development","title":"\ud83d\udc69\ud83c\udffb\u200d\ud83d\udcbb For development","text":"<p>If you want to contribute to the project or modify the source code, a development installation with <code>maturin</code> is recommended.</p> <ol> <li> <p>Prerequisites</p> <p>Make sure you have a working Rust toolchain, or get it via rustup.rs.</p> </li> <li> <p>Clone the repository</p> <pre><code>git clone https://github.com/viventriglia/PyTECGg.git\ncd PyTECGg\n</code></pre> </li> <li> <p>Install and build</p> <pre><code>maturin develop\n</code></pre> <p><code>maturin</code> will compile the Rust core and link it to your environment. Any Python change will be reflected immediately, while Rust changes will require re-running <code>maturin develop</code> to recompile the binary.</p> </li> </ol>"},{"location":"quickstart/0-data-ingestion-setup/","title":"Data Ingestion &amp; Setup \ud83c\udfd7\ufe0f","text":"<p>The first step in any TEC analysis is loading the raw data and preparing the execution environment. <code>PyTECGg</code> uses a high-performance Rust backend to parse RINEX files, delivering data directly into a Polars <code>DataFrame</code> for maximum efficiency.</p>"},{"location":"quickstart/0-data-ingestion-setup/#parse-rinex-files-fast","title":"Parse RINEX files \u2014 fast \u26a1","text":"<p>The <code>parsing</code> module provides two main functions: <code>read_rinex_obs</code> for observations and <code>read_rinex_nav</code> for navigation messages.</p> <pre><code>from pathlib import Path\nfrom pytecgg.parsing import read_rinex_nav, read_rinex_obs\n\n# Define paths to your local files\nNAV_PATH = Path(\"./path/to/your/nav_file.rnx\")\nOBS_PATH = Path(\"./path/to/your/obs_file.rnx\")\n\n# Load navigation data\nnav_dict = read_rinex_nav(NAV_PATH)\n\n# Load observations and metadata\ndf_obs, rec_pos, rinex_version = read_rinex_obs(OBS_PATH)\n\n# Derive a standard 4-character receiver name from the filename\nrec_name = OBS_PATH.name[:4].lower()\n</code></pre> <p>Metadata Extraction</p> <p><code>read_rinex_obs</code> returns a <code>tuple</code>: along with the observation <code>DataFrame</code>, it automatically extracts the approximate ECEF position of the receiver and the RINEX version directly from the file header.</p>"},{"location":"quickstart/0-data-ingestion-setup/#setting-the-context","title":"Setting the Context \u2699\ufe0f","text":"<p>The <code>GNSSContext</code> acts as a centralised configuration and state manager for the entire processing pipeline. It ensures that coordinate validation, constellation normalisation, and metadata management are handled consistently across all modules.</p> <pre><code>from pytecgg import GNSSContext\n\nctx = GNSSContext(\n    receiver_pos=rec_pos,\n    receiver_name=rec_name,\n    rinex_version=rinex_version,\n    h_ipp=350_000,\n    systems=['G', 'E'],\n)\n</code></pre> <p>Context parameters are:</p> <ul> <li><code>receiver_pos</code>, <code>receiver_name</code>, <code>rinex_version</code>: receiver position in ECEF coordinates (in meters), station identifier, and RINEX version string, respectively.</li> <li><code>h_ipp</code>: the height (in meters) of the Ionospheric Pierce Point (IPP). This defines the altitude of the theoretical \"thin shell\" used for vertical mapping (typically 350 km).</li> <li><code>systems</code>: a list of constellation identifiers to be processed. <code>PyTECGg</code> supports <code>GPS</code> (<code>G</code>), <code>Galileo</code> (<code>E</code>), <code>GLONASS</code> (<code>R</code>), and <code>BeiDou</code> (<code>C</code>). You can provide full names (e.g. <code>Galileo</code>) or symbols (e.g. <code>E</code>).</li> </ul> <p>Initialising this object is mandatory: it serves as the required argument for all subsequent processing steps, including cycle-slip detection, IPP calculation, and bias estimation.</p> <p>Internal State Management</p> <p>The <code>GNSSContext</code> also maintains internal attributes like <code>glonass_channels</code> and <code>freq_meta</code>: these are automatically populated during the ephemeris and signal processing stages.</p>"},{"location":"quickstart/0-data-ingestion-setup/#rinex-utilities","title":"RINEX utilities \ud83d\udd27","text":"<p><code>PyTECGg</code> also provides utility functions to perform quick health checks on the parsed datasets and automate data retrieval.</p>"},{"location":"quickstart/0-data-ingestion-setup/#data-diagnostics","title":"Data Diagnostics","text":"<p>Once data is loaded, you can use <code>summarise_rinex_data</code> to verify signal availability and navigation coverage.</p> CodeExample Output <pre><code>from pytecgg.utils import summarise_rinex_data\n\nsummarise_rinex_data(obs_data, nav_dict)\n</code></pre> <pre><code>=======================================================\n\ud83d\udef0\ufe0f  GNSS RINEX DATA SUMMARY\n=======================================================\n\n\ud83d\udcc5 Temporal Coverage (OBS)\n\n- Start:    2025-03-28 00:00:00+00:00\n- End:      2025-03-28 23:59:30+00:00\n- Duration: 23:59:30\n- Sampling: 30.0s\n\n\ud83d\udce1 Constellations Breakdown (OBS)\n\nSys  | SVs  | Total Records   | Available Signals\n-------------------------------------------------\nC    | 39   | 561,006         | C1X, C2I, C5X, C6I, C7I, D2I, L1X, L2I, L5X, L6I, L7I, S1X, S2I, S5X, S6I, S7I\nE    | 27   | 352,425         | C1X, C5X, C6X, C7X, C8X, D1X, L1X, L5X, L6X, L7X, L8X, S1X, S5X, S6X, S7X, S8X\nG    | 31   | 220,278         | C1C, C2W, C5X, L1C, L2W, L5X, S1C, S2W, S5X\nR    | 23   | 153,268         | C1C, C1P, C2C, D1C, L1C, L2C, S1C, S2C\n\n\ud83d\udcd6 Ephemeris Coverage (NAV)\n\n- BEIDOU  :  54 satellites have at least an ephemeris\n- GALILEO :  31 satellites have at least an ephemeris\n- GLONASS :  25 satellites have at least an ephemeris\n- GPS     :  31 satellites have at least an ephemeris\n</code></pre>"},{"location":"quickstart/0-data-ingestion-setup/#download-rinex-files","title":"Download RINEX files","text":"INGV RING (ObS)BKG IGS (NAV) <p>The <code>download_obs_ring</code> function targets the INGV RING network. This network manages continuous GNSS stations across Italy and archives GNSS data from thousands of stations along the Eurasia-Africa plate boundary. The function handles station naming conventions: if a 4-character code like <code>GRO2</code> is provided, it is converted to the long-name format (e.g., <code>GRO200ITA</code>).</p> <pre><code>from pytecgg.utils import download_obs_ring\n\ndownload_obs_ring(\n    station_code=\"GRO200ITA\",\n    year=2025,\n    doys=[1, 55, 252],\n    output_path=Path(\"./data\")\n)\n</code></pre> <p>The function creates a subdirectory named after the <code>station_code</code> under the provided <code>output_path</code>. The above example will produce the following structure:</p> <pre><code>data/\n\u2514\u2500\u2500 GRO2/\n    \u251c\u2500\u2500 GRO200ITA_R_20250010000_01D_30S_MO.crx.gz\n    \u251c\u2500\u2500 GRO200ITA_R_20250550000_01D_30S_MO.crx.gz\n    \u2514\u2500\u2500 GRO200ITA_R_20252520000_01D_30S_MO.crx.gz\n</code></pre> <p>Multi-constellation navigation messages, providing aggregated data from the global IGS network, can be downloaded from the BKG GNSS Data Center.</p> <pre><code>from pytecgg.utils import download_nav_bkg\n\ndownload_nav_bkg(\n    year=2025,\n    doys=[1, 55, 252],\n    output_path=Path(\"./data\")\n)\n</code></pre> <p>The RINEX files are saved under the provided <code>output_path</code>.</p>"},{"location":"quickstart/1-preprocessing-geometry/","title":"Preprocessing &amp; Geometry \ud83d\udef0\ufe0f","text":"<p>This stage transforms raw observations into high-quality, geometrically-referenced time series, determining exactly where the ionospheric observations took place.</p>"},{"location":"quickstart/1-preprocessing-geometry/#ephemeris-preparation","title":"Ephemeris Preparation \ud83d\udcd0","text":"<p>The first step is filtering global navigation messages and preparing ephemerides. Beyond preparing data for orbital propagation, this function enriches the <code>GNSSContext</code> with GLONASS <code>frequency_channels</code> (if <code>R</code> is among the requested constellations).</p> <pre><code>from pytecgg.satellites import prepare_ephemeris\n\nephem_dict = prepare_ephemeris(nav_dict, ctx=ctx)\n</code></pre>"},{"location":"quickstart/1-preprocessing-geometry/#signal-processing","title":"Signal Processing \ud83d\udd0e","text":"<p>Starting from the basic observables and given a <code>GNSSContext</code>, <code>PyTECGg</code> can compute the following linear combinations, useful for removing biases or isolating physical effects:</p> <ul> <li>Geometry-Free Linear Combination (GFLC), sensitive to ionospheric effects.</li> <li>Ionosphere-Free Linear Combination (IFLC), used to eliminate the ionospheric delay.</li> <li>Melbourne-W\u00fcbbena (MW) combination, useful for cycle-slip detection and ambiguity resolution.</li> </ul> <pre><code>from pytecgg.linear_combinations import calculate_linear_combinations\nfrom pytecgg.tec_calibration import extract_arcs\n\n# Compute selected linear combinations\ndf_lc = calculate_linear_combinations(\n    df_obs,\n    ctx=ctx,\n    combinations=[\"gflc_phase\", \"gflc_code\", \"mw\"]\n)\n\n# Identify continuous arcs, detect cycle slips\n# and loss-of-lock events\ndf_arcs = extract_arcs(\n    df=df_lc,\n    ctx=ctx,\n    threshold_abs=10,\n    threshold_std=10,\n    threshold_jump=5\n)\n</code></pre> <p>Processing parameters and options:</p> <ul> <li><code>combinations</code>: defines which signals to compute. Options include GFLC (<code>gflc_phase</code>, <code>gflc_code</code>), IFLC (<code>iflc_phase</code>, <code>iflc_code</code>), and MW (<code>mw</code>).</li> <li><code>extract_arcs</code>: outputs a Polars <code>DataFrame</code> containing unique arc identifiers (<code>id_arc_valid</code>) and arc-levelled GFLC values, essential for accurate bias estimation.</li> <li><code>threshold_abs</code> &amp; <code>threshold_std</code>: absolute and standard deviation thresholds used on the MW combination to detect cycle slips.</li> <li><code>threshold_jump</code>: tolerance for detecting and correcting residual jumps within an arc.</li> <li><code>max_gap</code>: an be explicitly set or automatically inferred from the data; if the time gap between consecutive epochs becomes too large, a loss-of-lock is declared</li> </ul>"},{"location":"quickstart/1-preprocessing-geometry/#orbital-propagation","title":"Orbital Propagation \ud83c\udf0d","text":"<p>To locate the ionospheric samples, we must first compute the satellite positions in the ECEF frame.</p> <pre><code>from pytecgg.satellites import satellite_coordinates\n\n# Compute satellitess ECEF coordinates\ndf_coords = satellite_coordinates(\n    sv_ids=df_arcs[\"sv\"],\n    epochs=df_arcs[\"epoch\"],\n    ephem_dict=ephem_dict\n)\n\n# Join coordinates with the observation data\ndf_geom = df_arcs.join(df_coords, on=[\"sv\", \"epoch\"], how=\"left\")\n</code></pre> <p><code>satellite_coordinates</code> provides the <code>X</code>, <code>Y</code>, <code>Z</code> positions of each satellite for every observed epoch.</p>"},{"location":"quickstart/1-preprocessing-geometry/#ionospheric-pierce-point-ipp","title":"Ionospheric Pierce Point (IPP) \ud83d\udccc","text":"<p>The IPP is the theoretical intersection between the satellite\u2013receiver line of sight and a thin-shell ionospheric model at the altitude defined in the <code>GNSSContext</code> (default: 350 km).</p> <pre><code>from pytecgg.satellites import calculate_ipp\n\ndf_final = calculate_ipp(df_geom, ctx=ctx, min_elevation=20)\n</code></pre> <p>This function appends geographic coordinates (<code>lat_ipp</code>, <code>lon_ipp</code>) and the mapping function values to the Polars <code>DataFrame</code>. The <code>min_elevation</code> argument sets a cut-off angle (in degrees) to filter satellites elevation.</p> <p>Elevation Masking</p> <p>Filtering out elevations below 20\u00b0 is highly recommended to feed cleaner data to the calibration model, as low-elevation signals are more susceptible to multipath and noise.</p>"},{"location":"quickstart/1-preprocessing-geometry/#wrapping-up","title":"Wrapping up \ud83c\udfc1","text":"<p>After completing all the preprocessing steps, your <code>DataFrame</code> is ready for the calibration engine: it now contains a rich set of features, that you can inspect using Polars selection methods.</p> <p>As an example, we may want to inspect arc metadata, like the unique identifier for each continuous observation sequence (<code>id_arc_valid</code>); the corrected and levelled GFLC (<code>gflc_levelled</code>, in TECu); and some geometric features, like the geographic IPP location (<code>lat_ipp</code>, <code>lon_ipp</code>) and the viewing geometry from the station (<code>azi</code>, <code>ele</code>).</p> CodeExample Output <pre><code>import polars as pl\n\ndf_final.filter(\n    pl.col(\"id_arc_valid\").is_not_null()\n).select(\n    [\n        \"epoch\",\n        \"sv\",\n        \"id_arc_valid\",\n        \"gflc_levelled\",\n        \"lat_ipp\",\n        \"lon_ipp\",\n        \"azi\",\n        \"ele\",\n    ]\n).head()\n</code></pre> epoch sv id_arc_valid gflc_levelled lat_ipp lon_ipp azi ele 00:00:00 E02 \"bneu_e02_001\" 42.39 20.40 96.31 257.73 26.55 00:00:00 E03 \"bneu_e03_001\" 42.11 23.51 99.84 314.36 47.16 00:00:00 E05 \"bneu_e05_001\" 44.97 20.75 101.93 179.50 73.10 00:00:00 E16 \"bneu_e16_001\" 11.03 23.88 102.24 27.57 52.26 00:00:00 E25 \"bneu_e25_001\" 34.64 22.97 100.76 321.15 59.68"},{"location":"quickstart/2-tec-calibration/","title":"TEC calibration \u2696\ufe0f","text":"<p>The calibration process is a fundamental step in GNSS-based ionospheric studies. Its goal is to estimate and remove the hardware-related inter-frequency biases (often referred to as Differential Code Biases, or DCBs) from both the transmitting satellites and the receiving hardware.</p> <p><code>PyTECGg</code> implements a modern version of the calibration algorithm described by Ciraolo et al. (2007). This approach addresses the systematic errors introduced during the \"levelling\" process (where carrier-phase observations are aligned with code-delay data) and accounts for the short-term instability of receiver biases.</p>"},{"location":"quickstart/2-tec-calibration/#how-it-works","title":"How it works \ud83d\udcac","text":"<p>The calibration computes both slant TEC (sTEC) and vertical TEC (vTEC) by modeling the ionosphere as a thin shell at a fixed altitude. The spatial variation of the ionospheric delay is represented using a polynomial expansion of the shell up to a configurable degree (<code>max_degree</code>, default is 3).</p> <p>To ensure temporal stability and account for intra-day variations of the hardware biases, the calibration is performed in batches of size <code>batch_size_epochs</code>. This allows the model to remain responsive to ionospheric variations while mitigating the impact of code-delay multipath.</p> <p>To calibrate your TEC data, you need the prepared <code>DataFrame</code> (containing arc-levelled combinations and IPP coordinates) and the <code>GNSSContext</code>:</p> <pre><code>from pytecgg.tec_calibration import calculate_tec\n\ndf_calibrated = calculate_tec(\n    df_final, \n    ctx=ctx,\n    max_polynomial_degree=3,\n    batch_size_epochs=30\n)\n</code></pre> <p>Calibration Parameters:</p> <ul> <li><code>max_polynomial_degree</code>: maximum degree of the polynomial expansion used to model the ionosphere; default is 3.</li> <li><code>batch_size_epochs</code>: number of epochs per batch; smaller batches track bias variations more closely, while larger ones offer more stability; default is 30.</li> </ul>"},{"location":"quickstart/2-tec-calibration/#vertical-equivalent","title":"Vertical Equivalent \u2195\ufe0f","text":"<p>While <code>vtec</code> provides a vertical estimation for each satellite's specific IPP, the Vertical Equivalent (VEq) represents the synthetic state of the ionosphere directly above the GNSS station (zenith).</p> <p><code>veq</code> is derived from the constant coefficient of the ionospheric model computed during the calibration process. Since the model is centered on the receiver's coordinates, evaluating the polynomial at the station's zenith isolates the local ionospheric contribution, effectively filtering out spatial gradients captured by different satellites and providing a unique, continuous value for the station.</p> <pre><code>from pytecgg.tec_calibration import calculate_vertical_equivalent\n\ndf_veq = calculate_vertical_equivalent(\n    df_calibrated, \n    ctx=ctx,\n    max_polynomial_degree=3,\n    batch_size_epochs=30\n)\n</code></pre> <p><code>veq</code> becomes valuable for station-level time-series analysis, as it mitigates individual satellite vulnerabilities.</p>"},{"location":"quickstart/2-tec-calibration/#wrapping-up","title":"Wrapping up \ud83c\udfc1","text":"<p>These functions estimate instrumental offsets and append calibrated physical values to the <code>DataFrame</code>. You can verify the results by inspecting the estimated biases, absolute TEC values, and the vertical equivalent over the station.</p> CodeExample Output <pre><code>df_veq.filter(\n    pl.col(\"id_arc_valid\").is_not_null()\n).select(\n    [\n        \"epoch\",\n        \"sv\",\n        \"id_arc_valid\",\n        \"gflc_levelled\",\n        \"azi\",\n        \"ele\",\n        \"bias\",\n        \"stec\",\n        \"vtec\",\n        \"veq\",\n    ]\n).head()\n</code></pre> epoch sv id_arc_valid gflc_levelled azi ele bias stec vtec veq 2025-04-05 00:00:00 G05 \"grot_g05_20250405_001\" -21.81 313.73 30.60 -34.04 12.23 7.07 9.77 2025-04-05 00:00:00 G07 \"grot_g07_20250405_001\" -29.87 49.06 61.13 -40.82 10.94 9.73 9.77 2025-04-05 00:00:00 G14 \"grot_g14_20250405_001\" -10.65 165.57 24.03 -32.77 22.12 11.07 9.77 2025-04-05 00:00:00 G30 \"grot_g30_20250405_001\" 0.05 237.84 79.88 -10.34 10.39 10.24 9.77 2025-04-05 00:00:30 G05 \"grot_g05_20250405_001\" -21.84 13.67 30.80 -34.04 12.20 7.08 9.77 <p>The new columns represent:</p> <ul> <li><code>bias</code>: estimated instrumental bias (in TECu) for the specific arc and batch.</li> <li><code>stec</code>: sTEC, corrected for hardware biases.</li> <li><code>vtec</code>: final vTEC, obtained by applying the mapping function to the sTEC.</li> <li><code>veq</code>: time series of the \"equivalent\" vertical TEC above the station (zenith).</li> </ul> <p>As shown below, while the scattered points represent vTEC at each satellite's IPP, the VEq solid line represents an estimation of the ionosphere directly above the station zenith. A good alignment of the different satellite tracks, which would otherwise be scattered at different vertical offsets, indicates that instrumental biases have been successfully estimated and removed.</p> <p></p> <p>Absolute TEC</p> <p>Unlike the relative geometry-free combination, vTEC provides the absolute electron content, making it directly comparable across different stations and satellites.</p> <p>vTEC vs VEq</p> <p>Unlike <code>vtec</code>, which shows different values for each satellite due to their different geographic IPP positions, <code>veq</code> provides a unique value per epoch, making it the ideal product for local ionospheric trend analysis.</p>"},{"location":"quickstart/3-batch-processing/","title":"Batch Processing \ud83d\uddc3\ufe0f","text":"<p>When moving from single-file analysis to processing multi-day time series, <code>PyTECGg</code> leverages the efficiency of Polars to handle data with minimal overhead.</p>"},{"location":"quickstart/3-batch-processing/#data-acquisition","title":"Data Acquisition \ud83d\udce5","text":"<p>In a typical scenario, you might start with several observation files placed under <code>data/obs</code>. <code>PyTECGg</code> allows you to automatically fetch broadcast navigation files from global repositories.</p> <pre><code>from pathlib import Path\nfrom pytecgg.utils import download_nav_bkg\n\n# Time window\nYEAR = 2026\nDOYS = list(range(55, 60))\n\n# Define data paths\nobs_path = Path(\"data/obs\")\nnav_path = Path(\"data/nav\")\n\ndownload_nav_bkg(\n    year=YEAR,\n    doys=DOYS,\n    output_path=nav_path,\n)\n</code></pre>"},{"location":"quickstart/3-batch-processing/#multi-day-analysis","title":"Multi-day Analysis \ud83d\uddd3\ufe0f","text":"<p>An easy way to process a long time series for a single station <code>STAT</code> is to concatenate observations before entering the calibration engine. This ensures that <code>extract_arcs</code> can track satellite arcs across day boundaries, preventing artificial bias jumps at midnight.</p> <pre><code>import polars as pl\nfrom pytecgg.parsing import read_rinex_obs, read_rinex_nav\n\n# Collect and concatenate observations for station 'STAT'\nobs_files = sorted(obs_path.glob(\"STAT*.rnx\"))\nall_obs = pl.concat([read_rinex_obs(f)[0] for f in obs_files])\n\n# Consolidate navigation messages into a dictionary\nnav_files = sorted(nav_path.glob(\"BRDC*.rnx.gz\"))\nfull_nav = {}\n\nfor f_ in nav_files:\n    day_nav = read_rinex_nav(f_)\n    for system, df_nav in day_nav.items():\n        full_nav[system] = pl.concat(\n            [full_nav.get(system, pl.DataFrame()), df_nav]\n        )\n</code></pre> <p>Once your data is consolidated, the workflow follows the standard pipeline but operates on the entire time series at once.</p> <pre><code>from pytecgg.satellites import prepare_ephemeris, satellite_coordinates, calculate_ipp\nfrom pytecgg.linear_combinations import calculate_linear_combinations\nfrom pytecgg.tec_calibration import (\n    extract_arcs,\n    calculate_tec,\n    calculate_vertical_equivalent,\n)\n\n# Enrich context and compute coordinates\nephem_dict = prepare_ephemeris(full_nav, ctx)\ndf_coords = satellite_coordinates(all_obs[\"sv\"], all_obs[\"epoch\"], ephem_dict)\n\n# Extract arcs and compute satellites' geometry\ndf_lc = calculate_linear_combinations(all_obs, ctx)\ndf_arcs = extract_arcs(df_lc, ctx, min_arc_length=120).join(\n    df_coords, on=[\"sv\", \"epoch\"], how=\"left\"\n)\ndf_geom = calculate_ipp(df_arcs, ctx, min_elevation=20)\n\n# Final calibrated products\ndf_cal = calculate_tec(df_geom, ctx=ctx)\ndf_veq = calculate_vertical_equivalent(df_cal, ctx=ctx)\n</code></pre>"},{"location":"quickstart/3-batch-processing/#wrapping-up","title":"Wrapping up \ud83c\udfc1","text":"<p>As shown in the plot below, while individual satellite tracks (blue dots) reflect specific ionospheric conditions at different IPPs, the VEq (solid black line) provides a continuous, stable estimation of the ionospheric electron content directly above the station zenith.</p> <p></p> <p>Batch processing effectively smooths out individual satellite noise and spatial gradients, providing a reliable TEC estimation even across day boundaries.</p>"},{"location":"reference/context/","title":"Context","text":"<p>The <code>context</code> module provides a unified state management system for the entire processing pipeline. <code>GNSSContext</code> ensures that all modules \u2013 from parsing to final calibration \u2013 operate with consistent settings, receiver position, ionospheric shell height, and GNSS constellations, thus acting as a single source of truth.</p>"},{"location":"reference/context/#api-reference","title":"API Reference","text":""},{"location":"reference/context/#pytecgg.context.GNSSContext","title":"<code>GNSSContext</code>  <code>dataclass</code>","text":"<p>Centralised configuration and state management for GNSS Total Electron Content (TEC) analysis.</p> <p>The GNSSContext acts as a single source of truth for the processing pipeline. It handles coordinate validation, constellation name normalisation, and maintains metadata required for geometric and frequency-dependent calculations.</p> <p>Attributes:</p> Name Type Description <code>receiver_pos</code> <code>tuple[float, float, float]</code> <p>Receiver coordinates in the Earth-Centered, Earth-Fixed (ECEF) frame, expressed in meters (X, Y, Z).</p> <code>receiver_name</code> <code>str</code> <p>Station identifier. Automatically normalised to lowercase and truncated to the first 4 characters (standard RINEX style).</p> <code>rinex_version</code> <code>str</code> <p>The version of the source RINEX file (e.g., \"2.11\", \"3.04\").</p> <code>h_ipp</code> <code>float</code> <p>The altitude of the thin-shell ionospheric model in meters. Default is 350,000 m (350 km).</p> <code>systems</code> <code>list[str]</code> <p>List of active GNSS constellations, accepting full names or symbols: GPS (G), GLONASS (R), Galileo (E), BeiDou (C).</p> <code>glonass_channels</code> <code>dict[str, int]</code> <p>Mapping of frequency channels for GLONASS satellites (e.g., {'R01': 1}). This attribute gets populated during ephemeris parsing.</p> <code>freq_meta</code> <code>dict[str, Any]</code> <p>Additional metadata related to signal frequencies and observation types used during processing.</p> Notes <p>The class performs validation and sanitisation steps during <code>__post_init__</code>:</p> <ul> <li>Validates that <code>receiver_pos</code> is a 3-element numeric structure.</li> <li>Maps constellation names to standard symbols of supported constellations.</li> <li>Issues a <code>UserWarning</code> if <code>h_ipp</code> falls outside the typical geophysical     range of [250, 500] km.</li> <li>Ensures at least one valid GNSS system is specified for processing.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ctx = GNSSContext(\n...     receiver_pos=(4444444.0, 1111111.0, 1234567.0),\n...     receiver_name=\"GROT\",\n...     rinex_version=\"3.04\",\n...     systems=[\"GPS\", \"Galileo\"],\n... )\n&gt;&gt;&gt; ctx.systems\n['G', 'E']\n&gt;&gt;&gt; ctx.receiver_name\n'grot'\n</code></pre>"},{"location":"reference/context/#pytecgg.context.GNSSContext.symbol_to_name","title":"<code>symbol_to_name</code>  <code>property</code>","text":"<p>Inverse mapping of GNSS systems active in the context.</p>"},{"location":"reference/parsing/","title":"Parsing","text":"<p>The <code>parsing</code> module is the entry point for data ingestion in <code>PyTECGg</code>. It leverages a high-performance Rust backend to handle the heavy lifting of reading RINEX files, ensuring that even large multi-constellation observation files are processed with minimal latency. By delegating the parsing logic to Rust and returning native Polars <code>DataFrame</code>s, <code>PyTECGg</code> avoids the common bottlenecks of Python-based RINEX readers. The module automatically handles:</p> <ul> <li>Format detection: support for standard <code>.rnx</code>, Hatanaka-compressed <code>.crx</code>, and gz-ipped <code>.gz</code> files.</li> <li>Metadata extraction: retrieval of the receiver ECEF position and RINEX version.</li> <li>Timezone normalization: epochs are automatically converted to UTC to ensure consistency across different GNSS datasets.</li> </ul>"},{"location":"reference/parsing/#api-reference","title":"API Reference","text":""},{"location":"reference/parsing/#pytecgg.parsing.read_rinex_obs","title":"<code>read_rinex_obs(path)</code>","text":"<p>Parses a RINEX observation file and returns the extracted observation data as a Polars DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the RINEX observation file (.rnx, .crx, or .gz).</p> required <p>Returns:</p> Type Description <code>tuple</code> <ul> <li>pl.DataFrame: DataFrame with columns 'epoch', 'sv', 'observable', 'value'</li> <li>tuple[float, float, float]: Receiver's position in ECEF coordinates (meters)</li> <li>str: RINEX version</li> </ul>"},{"location":"reference/parsing/#pytecgg.parsing.read_rinex_nav","title":"<code>read_rinex_nav(path)</code>","text":"<p>Parses a RINEX navigation file into a dictionary of DataFrames.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the RINEX navigation file.</p> required <p>Returns:</p> Type Description <code>dict[str, DataFrame]</code> <p>Dictionary keyed by constellation (e.g., 'GPS'), containing DataFrames with 'epoch' as datetime[\u03bcs, UTC] and orbital parameters.</p>"},{"location":"reference/satellites/","title":"Satellites &amp; Geometry","text":"<p>The <code>satellites</code> module provides essential functions for GNSS orbit propagation and observation geometry. It handles the transition from raw navigation messages to precise satellite positions and Ionospheric Pierce Points (IPP).</p>"},{"location":"reference/satellites/#orbital-models","title":"Orbital Models","text":"<p><code>PyTECGg</code> supports different orbital propagation models depending on the GNSS constellation:</p> <ol> <li>Keplerian model: used for GPS, Galileo, and BeiDou; it computes positions based on orbital elements valid for a few hours.</li> <li>State-Vector model: used for GLONASS; it performs numerical integration (via a Numba-accelerated ODE solver) of instantaneous position, velocity, and acceleration vectors.</li> </ol>"},{"location":"reference/satellites/#api-reference","title":"API Reference","text":""},{"location":"reference/satellites/#pytecgg.satellites.prepare_ephemeris","title":"<code>prepare_ephemeris(nav, ctx)</code>","text":"<p>Prepare ephemeris data from RINEX navigation data using the settings in GNSSContext.</p> <p>This function processes multiple GNSS constellations and formats data based on their specific orbit propagation models:</p> <ol> <li> <p>Keplerian Orbits (GPS, Galileo, BeiDou):     Selects a single representative ephemeris message (the central one) per satellite.</p> </li> <li> <p>State-Vector Orbits (GLONASS):     All available ephemeris messages are collected for the satellite. This is     required because GLONASS messages contain instantaneous state vectors (position/     velocity/acceleration) valid only for short periods (typically \u00b1 15 minutes),     requiring numerical integration from the closest epoch.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>nav</code> <code>dict[str, DataFrame]</code> <p>Navigation data from RINEX, keyed by constellation name (e.g., 'GPS', 'GLONASS').</p> required <code>ctx</code> <code>GNSSContext</code> <p>Execution context containing target systems and settings.</p> required <p>Returns:</p> Type Description <code>Ephem</code> <p>Dictionary keyed by satellite ID (e.g., 'G01', 'R09'). Values are a single dict for Keplerian systems or a list of dicts for GLONASS.</p>"},{"location":"reference/satellites/#pytecgg.satellites.satellite_coordinates","title":"<code>satellite_coordinates(sv_ids, epochs, ephem_dict, **kwargs)</code>","text":"<p>Compute Earth-Centered Earth-Fixed (ECEF) coordinates for GNSS satellites.</p> <p>The function supports GPS, Galileo, BeiDou (using Keplerian orbits) and GLONASS (using state-vector propagation).</p> <p>Parameters:</p> Name Type Description Default <code>sv_ids</code> <code>Series</code> <p>Series containing satellite identifiers (e.g., 'G01', 'E23', 'R01')</p> required <code>epochs</code> <code>Series</code> <p>Series containing observation times as datetime objects</p> required <code>ephem_dict</code> <code>dict</code> <p>Dictionary containing ephemeris data Expected format: {sv_id: dict} for Keplerian systems or {sv_id: list[dict]} for GLONASS.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional parameters for GLONASS state-vector propagation: - t_res : float or None, optional     Time resolution (in seconds) for sampling the ODE solver solution     - if float: the trajectory is sampled at fixed intervals     - if None (default): the solver selects internal time steps automatically. - error_estimate : Literal[\"coarse\", \"normal\", \"fine\"], optional     Error tolerance level:     - \"coarse\": ~2000 meters precision, faster     - \"normal\": ~200 meters precision, balanced (default)     - \"fine\": ~20 meters precision, slower</p> <p>These additional parameters are ignored for non-GLONASS systems</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: 'sv', 'epoch', 'sat_x', 'sat_y', 'sat_z' containing satellite ECEF coordinates in meters</p>"},{"location":"reference/satellites/#pytecgg.satellites.calculate_ipp","title":"<code>calculate_ipp(df, ctx, min_elevation=None)</code>","text":"<p>Calculate the Ionospheric Pierce Point (IPP) coordinates and satellite geometry.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame containing satellite ECEF coordinates ('sat_x', 'sat_y', 'sat_z').</p> required <code>ctx</code> <code>GNSSContext</code> <p>Context containing receiver position and IPP height.</p> required <code>min_elevation</code> <code>float</code> <p>Minimum elevation angle in degrees. If provided, observations below this threshold are filtered out.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with added columns: 'lat_ipp', 'lon_ipp', 'azi', 'ele'.</p>"},{"location":"reference/satellites/#pytecgg.satellites.Ephem","title":"<code>Ephem = dict[str, dict[str, Any] | list[dict[str, Any]]]</code>  <code>module-attribute</code>","text":"<p>Type alias for a dictionary containing processed ephemeris data.</p> <p>It maps satellite IDs (e.g., 'G01') to their specific orbital parameters,  handling both Keplerian (single dict) and state-vector (list of dicts) models.</p>"},{"location":"reference/tec_calibration/","title":"TEC Calibration","text":"<p>The <code>tec_calibration</code> module implements the core scientific logic for estimating and removing instrumental biases from GNSS observations. The calibration process is based on the algorithm described by Ciraolo et al. (2007). To account for the magnetic control of the ionosphere, the module takes into account Modified Dip latitude (MoDip), which provides a more physically accurate representation of ionospheric structures than standard geographic latitude.</p>"},{"location":"reference/tec_calibration/#key-stages","title":"Key Stages","text":"<ol> <li>Arc identification &amp; levelling: cycle slips and loss-of-lock events are detected to extract continuous observation \"arcs\"; phase measurements are then levelled to the (unambiguous) code measurements to reduce noise while maintaining continuity.</li> <li>Bias estimation: a polynomial expansion in a MoDip/Longitude frame is evaluated and the resulting system is solved using via QR decomposition to separate the ionospheric signal from the combined satellite-receiver biases.</li> <li>Calibrated output: estimated biases are removed to provide the calibrated slant (sTEC) and vertical (vTEC) TEC values.</li> </ol>"},{"location":"reference/tec_calibration/#api-reference","title":"API Reference","text":""},{"location":"reference/tec_calibration/#pytecgg.tec_calibration.extract_arcs","title":"<code>extract_arcs(df, ctx, threshold_abs=5.0, threshold_std=5.0, min_arc_length=30, max_gap=None, threshold_jump=10.0)</code>","text":"<p>Extract continuous TEC arcs and fix GNSS linear combinations for multiple constellations.</p> <p>The function performs the following steps: 1. Detects loss-of-lock events and cycle slips per constellation. 2. Identifies valid arcs, discarding short ones. 3. Removes cycle-slip jumps within valid arcs. 4. Corrects significant jumps between consecutive epochs. 5. Calculates arc-levelled GFLC values.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Input DataFrame containing GNSS observations.</p> required <code>ctx</code> <code>GNSSContext</code> <p>Execution context containing system configurations and frequency metadata.</p> required <code>threshold_abs</code> <code>float</code> <p>Absolute threshold for detecting cycle slips; default is 5.</p> <code>5.0</code> <code>threshold_std</code> <code>float</code> <p>Standard deviation multiplier threshold for cycle slips; default is 5.</p> <code>5.0</code> <code>min_arc_length</code> <code>int</code> <p>Minimum number of consecutive valid observations for an arc; default is 30.</p> <code>30</code> <code>max_gap</code> <code>timedelta</code> <p>Maximum allowed time gap before declaring Loss-of-Lock.</p> <code>None</code> <code>threshold_jump</code> <code>float</code> <p>Threshold for detecting significant jumps between epochs; default is 10.</p> <code>10.0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with arc identifiers and levelled GFLC values.</p>"},{"location":"reference/tec_calibration/#pytecgg.tec_calibration.calculate_tec","title":"<code>calculate_tec(df, ctx, max_polynomial_degree=3, batch_size_epochs=30)</code>","text":"<p>Compute slant and vertical TEC (sTEC, vTEC) after per-arc bias estimation.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>Input DataFrame containing GNSS observations, including: - gflc_levelled: leveled sTEC measurements - id_arc_valid: valid arc identifiers - ele: satellite elevation angles</p> required <code>ctx</code> <code>GNSSContext</code> <p>Execution context containing receiver position and IPP height.</p> required <code>max_polynomial_degree</code> <code>int</code> <p>Maximum degree of polynomial expansion used in calibration.</p> <code>3</code> <code>batch_size_epochs</code> <code>int</code> <p>Number of epochs per batch for calibration.</p> <code>30</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with additional columns: - bias: estimated arc-level bias - stec: bias-corrected slant TEC - vtec: vertical TEC after mapping function correction</p>"},{"location":"reference/tec_calibration/#pytecgg.tec_calibration.extract_modip","title":"<code>extract_modip(coords, year, coord_type)</code>","text":"<p>Interpolate MoDip values for given ECEF or geodetic (longitude/latitude) coordinates. The function interpolates MoDip values from precomputed grids, if available.</p> <p>Parameters:</p> Name Type Description Default <code>coords</code> <code>tuple, sequence, or np.ndarray</code> <p>Input coordinates, in one of the following forms: - (lon, lat) tuple of arrays - (x, y, z) tuple of arrays - Sequence of (lon, lat) tuples - Sequence of (x, y, z) tuples - np.ndarray of shape (N, 2) or (N, 3)</p> required <code>year</code> <code>int</code> <p>Year for which the MoDip grid is used.</p> required <code>coord_type</code> <code>Literal['ecef', 'geo']</code> <p>Type of input coordinates: - \"ecef\" for ECEF coordinates. - \"geo\" for geographic coordinates; lon, lat expected.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Interpolated MoDip values for the specified coordinates</p>"},{"location":"reference/utils/","title":"Utils \ud83d\udee0\ufe0f","text":"<p>The <code>utils</code> module provides helper functions to inspect the parsed datasets, and to download RINEX files. About the latter, to perform TEC analysis you need both Observation (from the station) and Navigation (global ephemerides) files: <code>PyTECGg</code> simplifies this with dedicated downloaders:</p> <ul> <li>INGV RING Network: targeted at the Italian GNSS network, downloading high-quality 30s observation files.</li> <li>BKG IGS Global: Downloads aggregated multi-constellation navigation files (BRDC), essential for orbit propagation.</li> </ul>"},{"location":"reference/utils/#api-reference","title":"API Reference","text":""},{"location":"reference/utils/#pytecgg.utils.summarise_rinex_data","title":"<code>summarise_rinex_data(obs, nav)</code>","text":"<p>Print a diagnostic summary of GNSS RINEX data.</p> <p>This utility provides a high-level overview of the dataset's temporal coverage, constellation and signal availability. It is designed to help users verify if the loaded observations contain the desidered frequency pairs and tracking channels (e.g., C, L, S, I, Q) required for accurate TEC calibration.</p> <p>Parameters:</p> Name Type Description Default <code>obs</code> <code>DataFrame</code> <p>Observation data in long format, as returned by <code>read_rinex_obs</code>.</p> required <code>nav</code> <code>dict[str, DataFrame]</code> <p>Navigation data dictionary keyed by constellation symbol, as returned by <code>read_rinex_nav</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <p>The summary is printed directly to the standard output.</p>"},{"location":"reference/utils/#pytecgg.utils.download_obs_ring","title":"<code>download_obs_ring(station_code, year, doys, output_path)</code>","text":"<p>Download RINEX observation files (Hatanaka crx.gz) from the INGV RING server.</p> <p>Automatically handles station code conversion (e.g., converts 4-character codes like 'GRO2' to 'GRO200ITA') and organizes files into station-specific subdirectories.</p> <p>Parameters:</p> Name Type Description Default <code>station_code</code> <code>str</code> <p>The station identifier (4 or 9 characters). Example: 'GRO2' or 'GRO200ITA'.</p> required <code>year</code> <code>int</code> <p>The observation year (e.g., 2023).</p> required <code>doys</code> <code>list[int]</code> <p>A list of Days Of Year (DOY), e.g., [1, 2, 3].</p> required <code>output_path</code> <code>Path</code> <p>The root directory where the files will be saved.</p> required Notes <p>Data Source: https://webring.gm.ingv.it:44324/rinex/RING</p>"},{"location":"reference/utils/#pytecgg.utils.download_nav_bkg","title":"<code>download_nav_bkg(year, doys, output_path)</code>","text":"<p>Download global navigation RINEX files (BRDC) from the BKG server.</p> <p>BRDC files contain multi-constellation navigation messages aggregated from the global IGS station network.</p> <p>Parameters:</p> Name Type Description Default <code>year</code> <code>int</code> <p>The observation year (e.g., 2023).</p> required <code>doys</code> <code>List[int]</code> <p>A list of Days Of Year (DOY).</p> required <code>output_path</code> <code>Path</code> <p>The directory where the navigation files will be saved.</p> required Notes <p>Data Source: https://igs.bkg.bund.de/root_ftp/IGS/BRDC</p>"}]}